// Prisma schema for Supabase PostgreSQL

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// Auth Models

model User {
  id                  String         @id @default(uuid())
  username            String         @unique
  email               String         @unique
  password            String
  name                String?
  avatar              String?
  bio                 String?
  website             String?
  isVerified          Boolean        @default(false)
  isBanned            Boolean        @default(false)
  isVip               Boolean        @default(false)
  vipUntil            DateTime?
  createdAt           DateTime       @default(now())
  updatedAt           DateTime       @updatedAt
  posts               Post[]
  sessions            Session[]
  likes               Like[]
  saves               Save[]
  shares              Share[]
  reports             Report[]
  messages            Message[]
  chats               Chat[]         @relation("ChatMembers")
  sentChatRequests    ChatRequest[]  @relation("SentChatRequests")
  receivedChatRequests ChatRequest[] @relation("ReceivedChatRequests")
  notifications       Notification[] @relation("UserNotifications")
  triggeredNotifications Notification[] @relation("ActorNotifications")
  followers           Follow[]       @relation("UserFollowers")
  following           Follow[]       @relation("UserFollowing")
  payments            Payment[]

  @@index([isVip])
  @@index([isBanned])
  @@index([isVerified])
  @@index([createdAt(sort: Desc)])
  @@map("users")
}

model Session {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@map("sessions")
}

model Post {
  id           String         @id @default(uuid())
  title        String
  description  String?
  thumbnailUrl String?
  imageUrls    String[]       @default([])
  videoUrls    String[]       @default([])
  categories   String[]       @default([])
  actressIds   String[]       @default([])
  tags         String[]       @default([])
  published    Boolean        @default(true)
  isVip        Boolean        @default(false)
  sourceUrl    String?
  scheduledFor DateTime?
  views        Int            @default(0)
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  authorId     String
  author       User           @relation(fields: [authorId], references: [id], onDelete: Cascade)
  likes        Like[]
  saves        Save[]
  shares       Share[]
  reports      Report[]

  @@index([authorId])
  @@index([views])
  @@index([scheduledFor])
  @@index([published, scheduledFor])
  @@index([createdAt(sort: Desc)])
  @@index([published, createdAt(sort: Desc)])
  @@index([isVip])
  @@index([published, isVip])
  @@index([categories], type: Gin)
  @@index([actressIds], type: Gin)
  @@index([tags], type: Gin)
  @@map("posts")
}

model Like {
  id        String   @id @default(uuid())
  userId    String
  postId    String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@unique([userId, postId])
  @@index([userId])
  @@index([postId])
  @@index([postId, createdAt(sort: Desc)])
  @@index([createdAt(sort: Desc)])
  @@map("likes")
}

model Save {
  id        String   @id @default(uuid())
  userId    String
  postId    String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@unique([userId, postId])
  @@index([userId])
  @@index([postId])
  @@index([userId, createdAt(sort: Desc)])
  @@index([postId, createdAt(sort: Desc)])
  @@index([createdAt(sort: Desc)])
  @@map("saves")
}

model Share {
  id        String   @id @default(uuid())
  userId    String
  postId    String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([postId])
  @@index([createdAt(sort: Desc)])
  @@index([userId, createdAt(sort: Desc)])
  @@map("shares")
}

model Report {
  id          String   @id @default(uuid())
  postId      String
  userId      String?
  type        String   // "dead_link", "inappropriate", "spam", etc.
  description String?
  status      String   @default("pending") // "pending", "resolved", "dismissed"
  createdAt   DateTime @default(now())
  resolvedAt  DateTime?
  resolvedBy  String?
  post        Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  user        User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([postId])
  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@map("reports")
}

model Chat {
  id              String        @id @default(uuid())
  isAccepted      Boolean       @default(false)
  lastMessageAt   DateTime?
  lastMessageText String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  messages        Message[]
  members         User[]        @relation("ChatMembers")
  request         ChatRequest?

  @@index([lastMessageAt(sort: Desc)])
  @@index([isAccepted])
  @@index([isAccepted, lastMessageAt(sort: Desc)])
  @@map("chats")
}

model ChatRequest {
  id         String   @id @default(uuid())
  chatId     String   @unique
  senderId   String
  receiverId String
  status     RequestStatus @default(PENDING)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  chat       Chat     @relation(fields: [chatId], references: [id], onDelete: Cascade)
  sender     User     @relation("SentChatRequests", fields: [senderId], references: [id], onDelete: Cascade)
  receiver   User     @relation("ReceivedChatRequests", fields: [receiverId], references: [id], onDelete: Cascade)

  @@index([senderId])
  @@index([receiverId])
  @@index([status])
  @@map("chat_requests")
}

model Message {
  id        String   @id @default(uuid())
  chatId    String
  senderId  String
  content   String
  read      Boolean  @default(false)
  createdAt DateTime @default(now())
  chat      Chat     @relation(fields: [chatId], references: [id], onDelete: Cascade)
  sender    User     @relation(fields: [senderId], references: [id], onDelete: Cascade)

  @@index([chatId])
  @@index([senderId])
  @@index([read])
  @@index([chatId, createdAt(sort: Desc)])
  @@index([chatId, read])
  @@index([createdAt(sort: Desc)])
  @@map("messages")
}

model Notification {
  id        String           @id @default(uuid())
  userId    String
  type      NotificationType
  title     String
  message   String
  link      String?
  read      Boolean          @default(false)
  actorId   String?
  createdAt DateTime         @default(now())
  user      User             @relation("UserNotifications", fields: [userId], references: [id], onDelete: Cascade)
  actor     User?            @relation("ActorNotifications", fields: [actorId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([createdAt])
  @@index([userId, read])
  @@index([userId, read, createdAt(sort: Desc)])
  @@index([read])
  @@map("notifications")
}

model Follow {
  id          String   @id @default(uuid())
  followerId  String
  followingId String
  createdAt   DateTime @default(now())
  follower    User     @relation("UserFollowing", fields: [followerId], references: [id], onDelete: Cascade)
  following   User     @relation("UserFollowers", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
  @@map("follows")
}

enum NotificationType {
  LIKE
  SAVE
  SHARE
  CHAT
  COMMENT
  FOLLOW
}

enum RequestStatus {
  PENDING
  ACCEPTED
  REJECTED
}

model Category {
  id          String   @id @default(uuid())
  name        String   @unique
  slug        String   @unique
  description String?
  imageUrl    String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("categories")
}

model Actress {
  id          String   @id @default(uuid())
  name        String   @unique
  slug        String   @unique
  bio         String?
  imageUrl    String?
  nationality String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([nationality])
  @@index([createdAt(sort: Desc)])
  @@map("actresses")
}

model Admin {
  id            String              @id @default(uuid())
  username      String              @unique
  email         String              @unique
  password      String
  name          String?
  role          AdminRole           @default(ADMIN)
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt
  sessions      AdminSession[]
  notifications AdminNotification[]

  @@map("admins")
}

model AdminSession {
  id        String   @id @default(uuid())
  adminId   String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  admin     Admin    @relation(fields: [adminId], references: [id], onDelete: Cascade)

  @@index([adminId])
  @@index([token])
  @@index([expiresAt])
  @@map("admin_sessions")
}

model Payment {
  id              String        @id @default(uuid())
  userId          String
  amount          Float
  currency        String        @default("USD")
  status          PaymentStatus @default(PENDING)
  paymentMethod   String        @default("oxapay")
  transactionId   String?       @unique
  description     String?
  metadata        Json?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@index([userId, status])
  @@index([status, createdAt(sort: Desc)])
  @@index([userId, createdAt(sort: Desc)])
  @@map("payments")
}

model ActivityLog {
  id          String       @id @default(uuid())
  action      LogAction
  entityType  String?
  entityId    String?
  userId      String?
  username    String?
  ipAddress   String?
  userAgent   String?
  details     Json?
  createdAt   DateTime     @default(now())

  @@index([action])
  @@index([userId])
  @@index([createdAt])
  @@index([userId, action, createdAt(sort: Desc)])
  @@index([entityType, entityId])
  @@index([action, createdAt(sort: Desc)])
  @@map("activity_logs")
}

model AdminNotification {
  id        String                 @id @default(uuid())
  adminId   String?
  type      AdminNotificationType
  title     String
  message   String
  link      String?
  read      Boolean                @default(false)
  metadata  Json?
  createdAt DateTime               @default(now())
  admin     Admin?                 @relation(fields: [adminId], references: [id], onDelete: SetNull)

  @@index([adminId])
  @@index([read])
  @@index([adminId, read])
  @@index([adminId, read, createdAt(sort: Desc)])
  @@index([createdAt(sort: Desc)])
  @@map("admin_notifications")
}

enum AdminRole {
  SUPER_ADMIN
  ADMIN
  MODERATOR
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

enum LogAction {
  USER_LOGIN
  USER_LOGOUT
  USER_REGISTER
  USER_UPDATE
  USER_DELETE
  USER_BAN
  USER_UNBAN
  POST_CREATE
  POST_UPDATE
  POST_DELETE
  POST_PUBLISH
  POST_UNPUBLISH
  PAYMENT_CREATE
  PAYMENT_COMPLETE
  PAYMENT_FAIL
  ADMIN_LOGIN
  ADMIN_LOGOUT
}

enum AdminNotificationType {
  PAYMENT_CREATED
  PAYMENT_COMPLETED
  PAYMENT_FAILED
  NEW_USER
  NEW_POST
  REPORT
  SYSTEM
}
